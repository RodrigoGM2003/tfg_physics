#version 440 core
#extension GL_NV_shader_atomic_float : enable // Required for atomicAdd on floats

#include "common_structs.glsl" // Must define PropertiesStruct and ContactManifold



// --- Buffers ---
// Input buffer containing object properties (mass, velocity etc.)
layout(std430, binding = 5) buffer PropertiesBuffer {
    PropertiesStruct properties[];
};

// Input buffer containing the count of active collisions for this frame/iteration
layout(std430, binding = 21) buffer CollisionCountBuffer{
    uint collisionCount; // Number of contacts in manifolds buffer
};

// The ContactManifold struct definition remains the same
struct ContactManifold {
    uint indexA;
    uint indexB;
    vec4 normal;          // World space, consistent direction (e.g., A->B)
    float depth;          // Penetration depth
};
// Input buffer with contact details generated by collision detection
layout(std430, binding = 26) buffer ContactManifoldBuffer {
    ContactManifold manifolds[];
};

// Output buffer where velocity changes are accumulated atomically
layout(std430, binding = 29) buffer DeltaVBuffer {
    vec4 deltaVs[]; // Accumulates deltaV.xyz for each object
};


uniform float delta_time;
// --- Shader Execution Configuration ---
layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in; // Workgroup size

// --- Main Shader Logic ---
void main() {
    // Get the unique global identifier for this shader invocation
    uint gid = gl_GlobalInvocationID.x;

    float BaumgarteBeta = 0.1;      // Factor for position correction strength (e.g., 0.1 to 0.3)
    float BaumgarteSlop = 0.01;      // Allowed penetration before correction activates (e.g., 0.01)
    float DefaultRestitution = 0.5; // Default bounciness (use 0.0 for stable stacking)
    // --- Boundary Check ---
    // Ensure this invocation corresponds to a valid contact manifold index
    // Access collisionCount safely (assuming it's set before dispatch)
    if (gid >= collisionCount) {
        return; // Exit if gid is out of bounds
    }

    // --- Read Contact Data ---
    ContactManifold contact = manifolds[gid];

    // --- Read Object Properties ---
    // It's often slightly more efficient to read the whole struct if accessing multiple members
    PropertiesStruct propsA = properties[contact.indexA];
    PropertiesStruct propsB = properties[contact.indexB];

    vec3 v1 = propsA.velocity.xyz;
    vec3 v2 = propsB.velocity.xyz;
    float invMass1 = propsA.inverseMass;
    float invMass2 = propsB.inverseMass;

    // --- Contact Info ---
    vec3 collisionNormal = contact.normal.xyz; // World space normal (e.g., A->B)
    float depth = contact.depth;             // Penetration depth

    // --- Calculate Relative Velocity ---
    vec3 relVel = v2 - v1;
    float relVelAlongNormal = dot(relVel, collisionNormal);

    // --- Resolve Collision and Penetration ---
    // We apply resolution if objects are moving towards each other (negative relative velocity along normal)
    // OR if they are penetrating more than the allowed slop (to push them apart even if moving slowly apart)
    if ((relVelAlongNormal < 0.0 && depth > BaumgarteSlop) || depth > BaumgarteSlop) {

        // Calculate the sum of inverse masses (used in impulse calculation)
        float invMassSum = invMass1 + invMass2;

        // Avoid division by zero or applying impulse if both objects are static/kinematic
        if (invMassSum > 0.00001f) { // Use a small epsilon comparison

            // --- Baumgarte Stabilization Bias ---
            // Calculate a velocity bias derived from the penetration depth.
            // This term aims to correct the position error over the next timestep.
            float inv_dt = 1.0 / delta_time;
            float bias = - BaumgarteBeta * inv_dt * max(0.0f, depth - BaumgarteSlop);

            // --- Restitution Term ---
            // Use the default restitution. Set to 0 for non-bouncy resting contact.
            // float restitution = relVelAlongNormal > 0.01f ? 0.9 : DefaultRestitution;
            float restitution = DefaultRestitution;
            // Advanced: Could vary restitution based on relVelAlongNormal (low velocity = low restitution)

            // --- Calculate Impulse Scalar (j) ---
            // Combines the standard collision response (restitution * velocity)
            // and the Baumgarte stabilization term (bias).
            // j = - (Relative Velocity component + Position Correction component) / Effective Mass
            float j = -(relVelAlongNormal * (1.0 + restitution) + bias) / invMassSum;

            // --- Impulse Clamping ---
            // In a simple iterative solver like this, we clamp the delta impulse calculated
            // in this iteration to be non-negative. This prevents objects from pulling each other together.
            // More advanced solvers using warm starting would clamp the *accumulated* impulse.
            float j_clamped = max(0.0f, j);

            // --- Calculate Impulse Vector ---
            vec3 impulse = j_clamped * collisionNormal;

            // --- Accumulate Velocity Changes Atomically ---
            // Calculate the change in velocity for each object (Impulse / Mass)
            vec3 deltaVA = -impulse * invMass1;
            vec3 deltaVB =  impulse * invMass2;

            // Atomically add the velocity changes. Requires the atomic float extension.
            // These deltaVs will be applied in a separate shader pass later.
            atomicAdd(deltaVs[contact.indexA].x, deltaVA.x);
            atomicAdd(deltaVs[contact.indexA].y, deltaVA.y);
            atomicAdd(deltaVs[contact.indexA].z, deltaVA.z);
            // deltaVs[contact.indexA].w remains untouched (usually 0)

            atomicAdd(deltaVs[contact.indexB].x, deltaVB.x);
            atomicAdd(deltaVs[contact.indexB].y, deltaVB.y);
            atomicAdd(deltaVs[contact.indexB].z, deltaVB.z);
            // deltaVs[contact.indexB].w remains untouched (usually 0)
        }
    }

    // --- Optional: Clear Processed Manifold ---
    // If the manifold buffer isn't guaranteed to be fully overwritten by collision
    // detection each frame, clearing it prevents stale data issues if collisionCount varies.
    // If CD always fills it densely from index 0, this might be unnecessary overhead.
    // Uncomment if needed:
    // ContactManifold blankContact;
    // blankContact.indexA = 0; // Or some invalid index like uint(-1)
    // blankContact.indexB = 0;
    // blankContact.normal = vec4(0.0f);
    // blankContact.depth = 0.0f;
    // manifolds[gid] = blankContact;
    
}