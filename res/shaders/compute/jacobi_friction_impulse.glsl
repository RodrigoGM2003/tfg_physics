#version 440 core
#extension GL_NV_shader_atomic_float : enable // Required for atomicAdd on floats

#include "common_structs.glsl" // Must define PropertiesStruct and ContactManifold



// --- Buffers ---
// Input buffer containing object properties (mass, velocity etc.)
layout(std430, binding = 5) buffer PropertiesBuffer {
    PropertiesStruct properties[];
};

// Input buffer containing the count of active collisions for this frame/iteration
layout(std430, binding = 21) buffer CollisionCountBuffer{
    uint collisionCount; // Number of contacts in manifolds buffer
};

// The ContactManifold struct definition remains the same
struct ContactManifold {
    uint indexA;
    uint indexB;
    vec4 normal;          // World space, consistent direction (e.g., A->B)
    float depth;          // Penetration depth

    vec4 rAWorld;
    vec4 rBWorld;
};
// Input buffer with contact details generated by collision detection
layout(std430, binding = 26) buffer ContactManifoldBuffer {
    ContactManifold manifolds[];
};

// Output buffer where velocity changes are accumulated atomically
layout(std430, binding = 29) buffer DeltaVBuffer {
    vec4 deltaVs[]; // Accumulates deltaV.xyz for each object
};


uniform float delta_time;
uniform float DefaultRestitution = 0.2;
uniform float DefaultFrictionCoefficient = 0.1;
// --- Shader Execution Configuration ---
layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in; // Workgroup size

// --- Main Shader Logic ---
void main() {
    // Get the unique global identifier for this shader invocation
    uint gid = gl_GlobalInvocationID.x;

    float BaumgarteBeta = 0.1;
    float BaumgarteSlop = 0.01;

    if (gid >= collisionCount ||  delta_time < 0.01f) {
        return; // Exit if gid is out of bounds
    }

    ContactManifold contact = manifolds[gid];

    PropertiesStruct propsA = properties[contact.indexA];
    PropertiesStruct propsB = properties[contact.indexB];

    vec3 v1 = propsA.velocity.xyz;
    vec3 v2 = propsB.velocity.xyz;
    float invMass1 = propsA.inverseMass;
    float invMass2 = propsB.inverseMass;

    vec3 collisionNormal = contact.normal.xyz; // World space normal (e.g., A->B)
    float depth = contact.depth;             // Penetration depth

 
    vec3 relVel = v2 - v1;
    float relVelAlongNormal = dot(relVel, collisionNormal);

    if (depth > BaumgarteSlop) { // Simplified from original: (relVelAlongNormal < 0.0 && depth > BaumgarteSlop) || depth > BaumgarteSlop

        // Calculate the sum of inverse masses (used in impulse calculation)
        float invMassSum = invMass1 + invMass2;

        // Avoid division by zero or applying impulse if both objects are static/kinematic
        if (invMassSum > 0.00001f) { // Use a small epsilon comparison

            // --- Baumgarte Stabilization Bias ---
            float inv_dt = 1.0 / delta_time;
            float bias = - BaumgarteBeta * inv_dt * max(0.0f, depth - BaumgarteSlop);

            // --- Restitution Term ---
            float restitution = DefaultRestitution;

            // --- Calculate Normal Impulse Scalar (j_normal_scalar) ---
            // j = - (Relative Velocity component + Position Correction component) / Effective Mass
            float j_normal_scalar = -(relVelAlongNormal * (1.0 + restitution) + bias) / invMassSum;

            // --- Normal Impulse Clamping ---
            // Clamp the normal impulse to be non-negative (prevent pulling).
            float j_normal_clamped = max(0.0f, j_normal_scalar);

            // Normal impulse vector (applied to B, -J_N to A)
            vec3 normalImpulseVec = j_normal_clamped * collisionNormal;

            // Initialize total impulse on B with the normal impulse
            vec3 totalImpulseOnB = normalImpulseVec;


            // --- Friction Impulse Calculation (Coulomb Friction Model) ---
            // 1. Calculate relative velocity tangential to the collision normal
            vec3 tangentVel = relVel - (relVelAlongNormal * collisionNormal);
            float tangentSpeed = length(tangentVel);

            if (tangentSpeed > 0.00001f) { // Apply friction only if there's significant tangential motion
                // 2. Determine friction direction (opposes relative tangential motion)
                // This is the direction of the friction impulse to be applied on body B
                vec3 frictionDir = -normalize(tangentVel);

                // 3. Calculate the scalar magnitude of the impulse needed to stop relative tangential motion
                float jt_to_stop = tangentSpeed / invMassSum;

                // 4. Calculate maximum friction impulse magnitude (Coulomb's Law: J_f <= mu * J_N)
                //    J_N is the magnitude of the normal impulse (j_normal_clamped)
                float maxFrictionImpulseMag = DefaultFrictionCoefficient * j_normal_clamped;

                // 5. The actual friction impulse magnitude is the minimum of what's needed to stop
                //    tangential motion and the maximum allowed by Coulomb's law.
                float frictionImpulseMag = min(jt_to_stop, maxFrictionImpulseMag);

                // 6. Calculate the friction impulse vector
                vec3 frictionImpulseVec = frictionImpulseMag * frictionDir;

                // 7. Add friction impulse to the total impulse on B
                totalImpulseOnB += frictionImpulseVec;
            }

            // --- Accumulate Total Velocity Changes Atomically ---
            // The total impulse on B is totalImpulseOnB.
            // The total impulse on A is -totalImpulseOnB.
            vec3 deltaVA = -totalImpulseOnB * invMass1;
            vec3 deltaVB =  totalImpulseOnB * invMass2;

            // Atomically add the velocity changes.
            atomicAdd(deltaVs[contact.indexA].x, deltaVA.x);
            atomicAdd(deltaVs[contact.indexA].y, deltaVA.y);
            atomicAdd(deltaVs[contact.indexA].z, deltaVA.z);

            atomicAdd(deltaVs[contact.indexB].x, deltaVB.x);
            atomicAdd(deltaVs[contact.indexB].y, deltaVB.y);
            atomicAdd(deltaVs[contact.indexB].z, deltaVB.z);
        }
    }

    // --- Optional: Clear Processed Manifold ---
    // If the manifold buffer isn't guaranteed to be fully overwritten by collision
    // detection each frame, clearing it prevents stale data issues if collisionCount varies.
    // If CD always fills it densely from index 0, this might be unnecessary overhead.
    // Uncomment if needed:
    // ContactManifold blankContact;
    // blankContact.indexA = 0; // Or some invalid index like uint(-1)
    // blankContact.indexB = 0;
    // blankContact.normal = vec4(0.0f);
    // blankContact.depth = 0.0f;
    // manifolds[gid] = blankContact;
    
}